version: "3"

vars:
  # Docker Hub images
  HUB_API_IMAGE: "grekodocker/autolab-api"
  HUB_PDF_IMAGE: "grekodocker/autolab-pdf"  # Now uses Playwright (lightweight)
  TAG:
    sh: git rev-parse --short HEAD
  # Helm/Kubernetes
  CHART_PATH: "./autolab-chart/autolab-chart/autolab"
  # Environment configs (dev is default)
  ENV: '{{.ENV | default "dev"}}'
  # Environment-specific settings
  NAMESPACE_dev: "autolab-dev"
  NAMESPACE_staging: "autolab-staging"
  NAMESPACE_prod: "autolab-prod0"
  RELEASE_dev: "autolab-dev"
  RELEASE_staging: "autolab-staging"
  RELEASE_prod: "autolab-prod"
  VALUES_dev: "values-dev.yaml"
  VALUES_staging: "values-staging.yaml"
  VALUES_prod: "values-prod.yaml"

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  # Docker build tasks (multi-architecture by default)
  buildx-setup:
    desc: Setup buildx builder for multi-architecture builds
    cmds:
      - docker run --privileged --rm tonistiigi/binfmt --install all
      - docker buildx create --name multiarch-builder --driver docker-container --bootstrap --use 2>/dev/null || docker buildx use multiarch-builder
    status:
      - docker buildx ls | grep -q multiarch-builder

  build:
    desc: Build and push all multi-arch Docker images (arm64 + amd64)
    deps:
      - buildx-setup
    cmds:
      - task: build-backend
      - task: build-pdfgen

  build-backend:
    desc: Build and push multi-arch backend image (arm64 + amd64)
    deps:
      - buildx-setup
    cmds:
      - echo "Building multi-arch backend image {{.HUB_API_IMAGE}}:{{.TAG}}..."
      - docker buildx build --builder multiarch-builder --platform linux/arm64,linux/amd64 -t {{.HUB_API_IMAGE}}:{{.TAG}} -t {{.HUB_API_IMAGE}}:latest --push .

  build-pdfgen:
    desc: Build and push multi-arch Playwright PDF generator image (arm64 + amd64)
    dir: pdf_backend_playwright
    deps:
      - buildx-setup
    cmds:
      - echo "Building multi-arch PDF generator image {{.HUB_PDF_IMAGE}}:{{.TAG}}..."
      - docker buildx build --builder multiarch-builder --platform linux/arm64,linux/amd64 -t {{.HUB_PDF_IMAGE}}:{{.TAG}} -t {{.HUB_PDF_IMAGE}}:latest --push .

  build-pdfgen-legacy:
    desc: Build legacy WeasyPrint PDF generator Docker image (single arch)
    dir: pdf_backend
    cmds:
      - docker build . -t {{.HUB_PDF_IMAGE}}:{{.TAG}}-legacy

  release:
    desc: Build and push all multi-arch Docker images to Docker Hub
    cmds:
      - task: build

  # Single-architecture build tasks (for local development)
  build-local:
    desc: Build local single-arch images (not pushed)
    cmds:
      - task: build-backend-local
      - task: build-pdfgen-local

  build-backend-local:
    desc: Build backend Docker image for local architecture only
    cmds:
      - docker build . -t {{.HUB_API_IMAGE}}:{{.TAG}} -t {{.HUB_API_IMAGE}}:latest

  build-pdfgen-local:
    desc: Build Playwright PDF generator Docker image for local architecture only
    dir: pdf_backend_playwright
    cmds:
      - docker build . -t {{.HUB_PDF_IMAGE}}:{{.TAG}} -t {{.HUB_PDF_IMAGE}}:latest

  # Helm deployment tasks - Multi-stage
  # Usage: task deploy (defaults to dev)
  # Usage: task deploy ENV=staging
  # Usage: task deploy ENV=prod
  deploy:
    desc: "Deploy to environment (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
      VALS: '{{index . (printf "VALUES_%s" .ENV)}}'
    cmds:
      - helm upgrade --install {{.REL}} {{.CHART_PATH}} --namespace {{.NS}} --create-namespace -f {{.CHART_PATH}}/{{.VALS}} --set image.tag={{.TAG}} --set pdfgen.image.tag={{.TAG}}

  deploy-dry-run:
    desc: "Preview Helm deployment (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
      VALS: '{{index . (printf "VALUES_%s" .ENV)}}'
    cmds:
      - helm upgrade --install {{.REL}} {{.CHART_PATH}} --namespace {{.NS}} --create-namespace -f {{.CHART_PATH}}/{{.VALS}} --set image.tag={{.TAG}} --set pdfgen.image.tag={{.TAG}} --dry-run

  # Convenience aliases for each environment
  deploy-dev:
    desc: Deploy to development (autolab-dev namespace)
    cmds:
      - task: deploy
        vars:
          ENV: dev

  deploy-staging:
    desc: Deploy to staging (autolab-staging namespace)
    cmds:
      - task: deploy
        vars:
          ENV: staging

  deploy-prod:
    desc: Deploy to production (autolab-prod0 namespace)
    cmds:
      - task: deploy
        vars:
          ENV: prod

  undeploy:
    desc: "Uninstall Helm release (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
    cmds:
      - helm uninstall {{.REL}} --namespace {{.NS}}

  redeploy:
    desc: "Build, push, and deploy (ENV=dev|staging|prod, default: dev)"
    cmds:
      - task: release
      - task: deploy

  redeploy-dev:
    desc: Build, push, and deploy to dev
    cmds:
      - task: release
      - task: deploy-dev

  redeploy-staging:
    desc: Build, push, and deploy to staging
    cmds:
      - task: release
      - task: deploy-staging

  redeploy-prod:
    desc: Build, push, and deploy to production
    cmds:
      - task: release
      - task: deploy-prod

  restart:
    desc: "Restart pods (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
    cmds:
      - kubectl rollout restart statefulset/{{.REL}}-autolab-api -n {{.NS}}
      - kubectl rollout restart deployment/autolab-pdfgen -n {{.NS}}

  status:
    desc: "Show deployment status (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
    cmds:
      - helm status {{.REL}} --namespace {{.NS}}
      - kubectl get pods -n {{.NS}} -l app.kubernetes.io/instance={{.REL}}

  status-all:
    desc: Show deployment status for all environments
    cmds:
      - echo "=== DEV (autolab-dev) ==="
      - kubectl get pods -n autolab-dev 2>/dev/null || echo "No pods in autolab-dev"
      - echo ""
      - echo "=== STAGING (autolab-staging) ==="
      - kubectl get pods -n autolab-staging 2>/dev/null || echo "No pods in autolab-staging"
      - echo ""
      - echo "=== PROD (autolab-prod0) ==="
      - kubectl get pods -n autolab-prod0 2>/dev/null || echo "No pods in autolab-prod0"

  logs:
    desc: "Show logs from API pod (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
    cmds:
      - kubectl logs -n {{.NS}} -l app=autolab-api --tail=100 -f

  logs-pdf:
    desc: "Show logs from PDF generator pod (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
    cmds:
      - kubectl logs -n {{.NS}} -l app=autolab-pdfgen --tail=100 -f

  # Secret management tasks
  secret-create:
    desc: "Create Kubernetes secret manually (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      JWT_SECRET:
        sh: openssl rand -base64 32
      LICENSE_SECRET:
        sh: openssl rand -base64 32
    cmds:
      - echo "Creating secret in namespace {{.NS}}..."
      - kubectl create secret generic autolab-api-secret --namespace {{.NS}} --from-literal=SECRET_KEY={{.JWT_SECRET}} --from-literal=SECRET_KEY_LICENSE={{.LICENSE_SECRET}} --from-file=admins.txt=backend-service-rust/admins.txt --dry-run=client -o yaml | kubectl apply -f -
      - echo "Secret created/updated successfully"

  secret-delete:
    desc: "Delete Kubernetes secret (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
    cmds:
      - kubectl delete secret autolab-api-secret --namespace {{.NS}} --ignore-not-found=true

  secret-recreate:
    desc: "Recreate Kubernetes secret (ENV=dev|staging|prod, default: dev)"
    cmds:
      - task: secret-delete
      - task: secret-create

  secret-show:
    desc: "Show current secret values (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
    cmds:
      - echo "Secret in namespace {{.NS}}:"
      - kubectl get secret autolab-api-secret --namespace {{.NS}} -o yaml 2>/dev/null || echo "Secret not found"

  # Helm install tasks using current kubectl context and commit hash
  helm-context:
    desc: Show current kubectl context and commit hash
    cmds:
      - echo "Current kubectl context:" && kubectl config current-context
      - echo "Current commit hash:" && echo {{.TAG}}
      - echo "Backend image:" && echo {{.HUB_API_IMAGE}}:{{.TAG}}
      - echo "PDF image:" && echo {{.HUB_PDF_IMAGE}}:{{.TAG}}

  helm-install:
    desc: "Install with current kubectl context and commit hash (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
      VALS: '{{index . (printf "VALUES_%s" .ENV)}}'
      CONTEXT:
        sh: kubectl config current-context
    cmds:
      - echo "Installing to context {{.CONTEXT}} with commit {{.TAG}}"
      - helm install {{.REL}} {{.CHART_PATH}} --namespace {{.NS}} --create-namespace -f {{.CHART_PATH}}/{{.VALS}} --set image.tag={{.TAG}} --set pdfgen.image.tag={{.TAG}} --kube-context={{.CONTEXT}}

  helm-upgrade:
    desc: "Upgrade with current kubectl context and commit hash (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
      VALS: '{{index . (printf "VALUES_%s" .ENV)}}'
      CONTEXT:
        sh: kubectl config current-context
    cmds:
      - echo "Upgrading in context {{.CONTEXT}} with commit {{.TAG}}"
      - helm upgrade {{.REL}} {{.CHART_PATH}} --namespace {{.NS}} -f {{.CHART_PATH}}/{{.VALS}} --set image.tag={{.TAG}} --set pdfgen.image.tag={{.TAG}} --kube-context={{.CONTEXT}}

  helm-install-or-upgrade:
    desc: "Install or upgrade with current kubectl context and commit hash (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
      VALS: '{{index . (printf "VALUES_%s" .ENV)}}'
      CONTEXT:
        sh: kubectl config current-context
    cmds:
      - echo "Installing/upgrading to context {{.CONTEXT}} with commit {{.TAG}}"
      - helm upgrade --install {{.REL}} {{.CHART_PATH}} --namespace {{.NS}} --create-namespace -f {{.CHART_PATH}}/{{.VALS}} --set image.tag={{.TAG}} --set pdfgen.image.tag={{.TAG}} --kube-context={{.CONTEXT}}

  # Development tasks
  dev:
    desc: Start frontend and backend in development mode
    deps:
      - task: frontend-deps
        silent: true
    cmds:
      - task: dev-parallel

  dev-browser:
    desc: Start frontend and backend in development mode and open browser
    deps:
      - task: frontend-deps
        silent: true
    cmds:
      - task: dev-parallel-with-browser

  dev-parallel-with-browser:
    desc: Run frontend, backend, and open browser in parallel
    deps:
      - task: frontend
      - task: backend
      - task: open-browser

  open-browser:
    desc: Wait for dev servers to start, then open browser
    cmds:
      - sleep 3
      - open http://localhost:5173

  frontend-deps:
    desc: Install frontend dependencies if needed
    dir: carpaintr-front
    status:
      - test -d node_modules
    cmds:
      - npm install

  dev-parallel:
    desc: Run frontend and backend in parallel
    deps:
      - task: frontend
      - task: backend

  frontend:
    desc: Start frontend development server
    dir: carpaintr-front
    cmds:
      - npm run dev

  backend:
    desc: Start backend with hot reload
    dir: backend-service-rust
    cmds:
      - cargo watch -x run

  # Integration testing tasks
  test:setup:
    desc: Setup integration test environment
    dir: backend-integration-tests
    cmds:
      - task setup

  test:
    desc: Run integration tests
    dir: backend-integration-tests
    cmds:
      - task test

  test:auth:
    desc: Run authentication integration tests
    dir: backend-integration-tests
    cmds:
      - task test:auth

  test:admin:
    desc: Run admin integration tests
    dir: backend-integration-tests
    cmds:
      - task test:admin

  test:cov:
    desc: Run integration tests with coverage
    dir: backend-integration-tests
    cmds:
      - task test:cov

  test:check:
    desc: Check if backend is running before tests
    dir: backend-integration-tests
    cmds:
      - task check-backend

  # Database management tasks
  db-reset:
    desc: "Reset database by deleting PVC (ENV=dev|staging, default: dev) - WARNING: DESTRUCTIVE - PRODUCTION BLOCKED"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
    preconditions:
      - sh: '[ "{{.ENV}}" != "prod" ]'
        msg: "BLOCKED - Database reset is not allowed on production environment. This is a safety measure to prevent data loss."
    cmds:
      - echo "WARNING - This will DELETE ALL DATA in {{.ENV}} environment!"
      - echo "Namespace - {{.NS}}"
      - echo "PVC - autolab-api-storage-{{.REL}}-autolab-api-0"
      - echo "Press Ctrl+C within 5 seconds to cancel..."
      - sleep 5
      - echo "Scaling down StatefulSet..."
      - kubectl scale statefulset/{{.REL}}-autolab-api --replicas=0 -n {{.NS}}
      - echo "Waiting for pod to terminate..."
      - kubectl wait --for=delete pod/{{.REL}}-autolab-api-0 -n {{.NS}} --timeout=60s || true
      - echo "Deleting PVC..."
      - kubectl delete pvc autolab-api-storage-{{.REL}}-autolab-api-0 -n {{.NS}}
      - echo "Scaling up StatefulSet..."
      - kubectl scale statefulset/{{.REL}}-autolab-api --replicas=1 -n {{.NS}}
      - echo "Waiting for pod to be ready..."
      - kubectl wait --for=condition=ready pod/{{.REL}}-autolab-api-0 -n {{.NS}} --timeout=120s
      - echo "Database reset complete! New empty database created."

  db-reset-dev:
    desc: Reset dev database (autolab-dev namespace) - WARNING DESTRUCTIVE
    cmds:
      - task: db-reset
        vars: {ENV: dev}

  db-reset-staging:
    desc: Reset staging database (autolab-staging namespace) - WARNING DESTRUCTIVE
    cmds:
      - task: db-reset
        vars: {ENV: staging}

  db-reset-prod-force:
    desc: "DANGEROUS - Force reset production database (requires CONFIRM_PROD=yes)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" "prod")}}'
      REL: '{{index . (printf "RELEASE_%s" "prod")}}'
    preconditions:
      - sh: '[ "{{.CONFIRM_PROD}}" = "yes" ]'
        msg: "BLOCKED - You must set CONFIRM_PROD=yes to reset production database. Example: task db-reset-prod-force CONFIRM_PROD=yes"
    cmds:
      - echo "CRITICAL WARNING - You are about to DELETE ALL PRODUCTION DATA!"
      - echo "Namespace - {{.NS}}"
      - echo "PVC - autolab-api-storage-{{.REL}}-autolab-api-0"
      - echo "This action is IRREVERSIBLE and will cause DOWNTIME!"
      - echo "Press Ctrl+C within 10 seconds to cancel..."
      - sleep 10
      - echo "Last chance - Press Ctrl+C within 5 seconds..."
      - sleep 5
      - echo "Scaling down StatefulSet..."
      - kubectl scale statefulset/{{.REL}}-autolab-api --replicas=0 -n {{.NS}}
      - echo "Waiting for pod to terminate..."
      - kubectl wait --for=delete pod/{{.REL}}-autolab-api-0 -n {{.NS}} --timeout=60s || true
      - echo "Deleting PVC..."
      - kubectl delete pvc autolab-api-storage-{{.REL}}-autolab-api-0 -n {{.NS}}
      - echo "Scaling up StatefulSet..."
      - kubectl scale statefulset/{{.REL}}-autolab-api --replicas=1 -n {{.NS}}
      - echo "Waiting for pod to be ready..."
      - kubectl wait --for=condition=ready pod/{{.REL}}-autolab-api-0 -n {{.NS}} --timeout=120s
      - echo "Production database reset complete. All data has been deleted."

  db-backup:
    desc: "Create manual backup now (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
      TIMESTAMP:
        sh: date +%s
    cmds:
      - echo "Creating manual backup in {{.NS}}..."
      - kubectl create job --from=cronjob/{{.REL}}-autolab-api-backup manual-backup-{{.TIMESTAMP}} -n {{.NS}}
      - echo "Backup job created - manual-backup-{{.TIMESTAMP}}"
      - echo "Check status with - kubectl logs -n {{.NS}} job/manual-backup-{{.TIMESTAMP}} -f"

  db-backup-dev:
    desc: Create manual backup of dev database
    cmds:
      - task: db-backup
        vars: {ENV: dev}

  db-list-backups:
    desc: "List available backups (ENV=dev|staging|prod, default: dev)"
    vars:
      NS: '{{index . (printf "NAMESPACE_%s" .ENV)}}'
      REL: '{{index . (printf "RELEASE_%s" .ENV)}}'
    cmds:
      - echo "Backups in {{.NS}}"
      - kubectl exec -n {{.NS}} statefulset/{{.REL}}-autolab-api -- ls -lh /backups/ 2>/dev/null || echo "No backups found or pod not ready"

  db-list-backups-dev:
    desc: List dev backups
    cmds:
      - task: db-list-backups
        vars: {ENV: dev}
